# Руководство по отладке OpenGL приложения

## Система логирования

В проекте реализована система логирования и проверки OpenGL ошибок через `src/utils/gl_debug.hpp`.

### Макросы логирования

```cpp
LOG_INFO(msg)   // Информационные сообщения
LOG_ERROR(msg)  // Ошибки
LOG_WARN(msg)   // Предупреждения
```

### Проверка OpenGL ошибок

```cpp
GL_CHECK(glCall());  // Автоматически проверяет ошибки после вызова
```

В Debug режиме (`CMAKE_BUILD_TYPE=Debug`) все OpenGL вызовы автоматически проверяются.
В Release режиме проверки отключены для производительности.

## Типичные ошибки и их диагностика

### 1. Segmentation Fault при загрузке меша

**Симптомы:**
```
/bin/sh: line 1: 23979 Segmentation fault: 11
```

**Причины:**
- Неправильный размер буфера при `glBufferData`
- Обращение к невалидной памяти
- Неинициализированные указатели

**Решение:**
Проверьте логи:
```
[INFO] Mesh::upload - vertices: 1234, indices: 5678
[INFO] Mesh::upload - VBO size: 49360 bytes
[INFO] Mesh::upload - EBO size: 22712 bytes (uint32_t size: 4)
```

Убедитесь, что размер EBO вычисляется как `indices.size() * sizeof(uint32_t)`, а не `sizeof(VertexPU)`!

### 2. GL_INVALID_OPERATION

**Причины:**
- Вызов OpenGL функции в неправильном контексте
- Использование несовместимых параметров
- Попытка рисовать без привязанного VAO

**Диагностика:**
```
[GL ERROR] GL_INVALID_OPERATION at mesh.cpp:75 in call: glDrawElements(...)
```

### 3. GL_OUT_OF_MEMORY

**Причины:**
- Слишком большой буфер
- Утечка памяти (не удаляются старые буферы)

**Решение:**
Проверьте, что `destroy()` вызывается перед повторной загрузкой меша.

### 4. Черный экран

**Причины:**
- Шейдеры не скомпилированы
- Неправильные uniform переменные
- VAO не привязан при рисовании
- Неправильные матрицы трансформации

**Диагностика:**
Включите логирование в `Mesh::draw()` и проверьте, что VAO != 0.

## Сборка в Debug режиме

```bash
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Debug ..
cmake --build .
```

## Запуск с отладчиком

### macOS (lldb)
```bash
lldb ./build/bin/main_app
(lldb) run
# При крэше:
(lldb) bt  # backtrace
(lldb) frame variable  # локальные переменные
```

### Linux (gdb)
```bash
gdb ./build/bin/main_app
(gdb) run
# При крэше:
(gdb) bt
(gdb) info locals
```

## Проверка утечек памяти

### macOS
```bash
leaks --atExit -- ./build/bin/main_app
```

### Linux (valgrind)
```bash
valgrind --leak-check=full ./build/bin/main_app
```

## Address Sanitizer

Добавьте в CMakeLists.txt:
```cmake
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address -fno-omit-frame-pointer")
```

Пересоберите и запустите - получите детальную информацию о проблемах с памятью.

## Полезные советы

1. **Всегда проверяйте размеры буферов** - используйте `sizeof()` правильного типа
2. **Логируйте критические операции** - загрузка файлов, создание буферов
3. **Проверяйте возвращаемые значения** - особенно при загрузке ресурсов
4. **Используйте RAII** - автоматическое управление ресурсами через деструкторы
5. **Тестируйте с простыми данными** - начните с куба/сферы перед загрузкой сложных моделей

## Чеклист при крэше

- [ ] Проверить логи загрузки модели
- [ ] Проверить размеры буферов (VBO/EBO)
- [ ] Проверить, что OpenGL контекст создан
- [ ] Проверить, что шейдеры скомпилированы
- [ ] Запустить с отладчиком и получить backtrace
- [ ] Проверить с Address Sanitizer
- [ ] Упростить сцену до минимума (один примитив)